{-
  Something we've discussed: the language will not support automatic handling
  of collisions between sprites, at least not now.

  init :: () -> State
  loop :: State -> State
-}

-- Sample program for Pong

mode Pong {

  graphics {
    font, basic
  }

  palettes {
    white
  }

  constants {
    START_POS: byte = 100     -- sort of middle starting position
    MIN_POS:   byte =  20
    MAX_POS:   byte = 200
  }

  state {
    left_pts:     byte
    right_pts:    byte
    left_paddle:  sprite Paddle
    right_paddle: sprite Paddle
    ball:         sprite Ball
    -- the mode should have some implicit state about the backgrounds used
  }

  init {
    left_pts     <- 0
    right_pts    <- 0
    left_paddle  <- Paddle(LEFT)  -- really? looks ugly
    right_paddle <- Paddle(RIGHT)

    -- background stuff. syntax here very not thought out at all!
    -- this sets up a dividing line in the middle of the screen
    for i = 0 to 27 do {
      bg0[15,i] <- basic[line]
    }
  }

  main {
    -- there's actually nothing that happens here?
  }

  routines {
    left_wins() {
      left_pts <- left_pts + 1
      display_score()

      left_paddle.reset() -- method call syntax?
      right_paddle.reset()

      ball.reset(RIGHT)
    }

    right_wins() {
      right_pts <- right_pts + 1
      display_score()

      left_paddle.reset()
      right_paddle.reset()

      ball.reset(LEFT)
    }

    display_score() {
      var (left_tens, left_ones): (byte, byte) = hex2dec(left_pts)
      var (right_tens, right_ones): (byte, byte) = hex2dec(right_pts)
      -- var is a local variable (should be constant binding in this case)
      -- hex2dec some utility function we probably provide in a standard library
      -- this implies the existence of some tuple type. maybe we don't have that

      bg0[12,1] <- font[left_tens]  -- again, syntax to reference graphics??
      bg0[13,1] <- font[left_ones]

      bg0[17,1] <- font[right_tens]
      bg0[18,1] <- font[right_ones]
    }
  }

  sprites {
    Paddle {
      graphics {
        PaddleGraphics  -- where/how is this defined?
      }

      palettes {
        WhitePalette  -- where/how is this defined?
      }

      animations {
        PaddleAnimation {
          {- omitted (read: haven't thought about) how to specify building
             full sprite animation frame out of smaller graphics

             ideally, you would write how the animation frame would be
             constructed from the supplied graphics, and we would figure out how
             to get that on the screen for you
          -}
        }
      }

      state {
        {-
          I think sprites should have some implicit state (reflecting what is
          always included in OAM:
           * x
           * y
           * palette
           * ...?
        -}
        con: controller  -- this is complicated---need to explain my thoughts
      }

      constants {
        START_POS: byte = 100     -- sort of middle starting position
        MIN_POS:   byte =  20
        MAX_POS:   byte = 200

        LEFT_POS:  byte =  10
        RIGHT_POS: byte = 245
      }

      init(player: enum { LEFT, RIGHT }) {
        -- initialize paddle position, depending on player, and also controller
        case player of {
          LEFT -> {
            con <- controller1 -- see above remark about how this is complex
            x <- LEFT_POS
          }
          RIGHT -> {
            con <- controller2
            x <- RIGHT_POS
          }
        }

        -- y position independent of player
        y <- START_POS
      }

      loop {
        {-
          Player can use up/down on controller to move paddle up and down,
          within bounds

          I'm thinking con are namespaces, not a value (method call)
          `holding` could be implemented as a macro or inlined function...
          but we are using it like a value!
        -}
        if con.holding(BUTTON_UP) and x >= MIN_POS then {
          x <- x - 1
        }
        if con.holding(BUTTON_DOWN) and x <= MAX_POS then {
          x <- x + 1  -- I have a thought here about multiple assignments to `x`
        }
      }

      methods {
        reset(): void {
          y <- START_POS
        }
      }
    }

    Ball {
      graphics {
        BallGraphics
      }

      palettes {
        WhitePalette
      }

      animations {
        BallAnimation {
          {- omitted (read: haven't thought about) how to specify building
             full sprite animation frame out of smaller graphics

             ideally, you would write how the animation frame would be
             constructed from the supplied graphics, and we would figure out how
             to get that on the screen for you
          -}
        }
      }

      state {
        horiz:  enum { LEFT, RIGHT } -- direction of ball
        vert:   enum { UP, DOWN }    -- enums? (could just be ints)
      }

      constants {
        LEFT_X:  byte = 5     -- \ defines bounds to declare winner left/right
        RIGHT_X: byte = 250   -- /
        MID_X:   byte = (LEFT_X + RIGHT_X) / 2 -- this should be static compute
        
        MIN_Y:   byte = 20    -- \ defines top/bottom for bouncing
        MAX_Y:   byte = 200   -- /
        MID_Y:   byte = (MIN_Y + MAX_Y) / 2
      }

      init(player) {
        direction <- if random(2) = 0 then LEFT else RIGHT
        -- random is an externally defined function?
      }

      loop {
        case horiz of {
          LEFT -> {
            if x < LEFT_X then { -- right wins
              call right_wins() -- this is really dangerous, and needs to be discussed
            } else {
              x <- x - 1
            }
          }
          RIGHT -> {
            if x > RIGHT_X then { -- left wins
              call left_wins()
            } else {
              x <- x + 1
            }
          }
        } 
      }

      methods {
        reset(direction) {
          y <- MID_Y
          x <- MID_X
          horiz <- direction
        }
      }

      interactions {
        {-
          WHO IS IN CHARGE OF DOING SPRITE INTERACTIONS!?!??!

          In general, I don't like the idea that a sprite can have its state
          changed because of a method call from another sprite. It should only
          be
            (1) the method called from the main game loop in the mode, or
            (2) method automatically called from an interaction
          Perhaps this doesn't matter because of my other crazy ideas about
          how to functionalize the main game loop.
        -}
        
        Paddle(x) { -- x is the paddle in question
          -- just flip the direction it's going
          if direction = LEFT then {
            direction <- RIGHT
          } else {
            direction <- LEFT
          }
        }
      }
    }
  }
}

